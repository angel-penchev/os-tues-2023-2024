# Тема 7. Мрежова комуникация
Съдържание:

1. [Какво е мрежова комуникация?](#1-какво-е-мрежова-комуникация)
2. [TCP/IP модел](#2-tcpip-модел)
3. [Мрежови протоколи. IPv4.](#3-мрежови-протоколи-ipv4)
4. [Транспортни протоколи. TCP и UDP](#4-транспортни-протоколи-tcp-и-udp)
5. [Полезни Unix команди при работа с мрежови устройства](#5-полезни-unix-команди-при-работа-с-мрежови-устройства)
6. [Модел сървър-клиент. Socket комуникация](#6-модел-сървър-клиент-socket-комуникация)
---

## 1. Какво е мрежова комуникация?
- Мрежовата комуникация се отнася до обмена на данни между различни устройства (компютри, сървъри, рутери и т.н.) чрез мрежова инфраструктура. Това включва използването на различни протоколи, които определят как данните се пакетират, предават и получават.

- Мрежовият протокол е съвкупност от правила, чрез които компютрите и останалите устройства в мрежата комуникират помежду си. Тези правила обхващат всичко от физическото свързване на устройствата до логическата обработка и предаване на данни, осигурявайки правилното и ефективно взаимодействие между компонентите на мрежата.

## 2. TCP/IP модел
![TCP/IP модел](https://media.geeksforgeeks.org/wp-content/uploads/20230417045622/OSI-vs-TCP-vs-Hybrid-2.webp)

- TCP/IP е концептуален модел на семейство от протоколи за комуникация между компютърни системи.
- Описва 7 слоя:
    - **Layer 1 (Physical Layer)** - Физически слой: Отговаря за предаването и приемането на сурови данни по физическа среда като кабели, радиовълни и т.н. Тук се дефинират електрически и механични спецификации на интерфейсите и медията.

    - **Layer 2 (Data Link Layer)** - Канален слой: Обезпечава надеждното предаване на данни между две свързани устройства. Тук се включват протоколи като Ethernet и PPP (Point-to-Point Protocol).

    - **Layer 3 (Network Layer)** - Мрежов слой: Отговаря за логическото адресиране и маршрутизирането на пакети данни в мрежата. Примерни протоколи са IP (Internet Protocol).

    - **Layer 4 (Transport Layer)** - Транспортен слой: Обезпечава надеждността и контрола на предаването на данни между две крайни точки в мрежата. Основните протоколи тук са TCP (Transmission Control Protocol) и UDP (User Datagram Protocol).

    - **Layer 5 (Session Layer)** - Сесиен слой: Управлява и контролира диалога (сесията) между два компютъра. Тук се осъществява установяване, поддържане и прекратяване на сесията.

    - **Layer 6 (Presentation Layer)** - Представителен слой: Отговаря за превръщането на данните от един формат в друг, за да бъдат разбираеми от приложния слой. Също така се грижи за криптиране и декриптиране на данни.

    - **Layer 7 (Application Layer)** - Приложен слой: Осигурява интерфейса за потребителските приложения, които комуникират през мрежата. Примери за протоколи тук са HTTP, FTP, SMTP и други.

Трябва да се отбележи, че TCP/IP моделът в действителност има само 4 слоя (Link, Internet, Transport и Application), но за сравнение с OSI модела тук са описани 7 слоя, съответстващи на OSI модела.

## 3. Мрежови протоколи - IPv4/IPv6

- Internet Protocol version 4 (IPv4) е основният комуникационен протокол за предаване на данни в Интернет. Той използва 32-битови адреси, които позволяват около 4.3 милиарда уникални адреса. Поради растящия брой устройства свързани в Интернет, IPv4 адресите са на изчерпване.

- **IPv4 адреси:**
  - IPv4 адресите се записват като четири осембитови числа, разделени с точки (напр. 192.168.0.1).
  - Разделят се на мрежова и хост част, като се използва маска на подмрежата (subnet mask) за определяне на границата между тях (напр. 255.255.255.0).
  - IPv4 адресите могат да бъдат публични (видими в интернет) или частни (използвани вътрешно в локалните мрежи, напр. 192.168.x.x, 10.x.x.x, 172.16.x.x до 172.31.x.x).

- Internet Protocol version 6 (IPv6) е следващото поколение на IP адресиране, разработено да реши проблема с изчерпването на адресите в IPv4. IPv6 използва 128-битови адреси, което осигурява практически неограничен брой уникални адреси. Преходът от IPv4 към IPv6 е бавен процес и двата протокола съществуват паралелно.

- **IPv6 адреси:**
  - IPv6 адресите се записват като осем групи от четири хексадецимални цифри, разделени с двоеточие (напр. 2001:0db8:85a3:0000:0000:8a2e:0370:7334).
  - Поддържат се различни типове адреси: уникаст (за едно устройство), мултикаст (за група устройства) и еникаст (един адрес, отговарящ на няколко местоположения, където се отговаря от най-близкото).


## 4. Транспортни протоколи - TCP и UDP

- Transmission Control Protocol (TCP) и User Datagram Protocol (UDP) са основните транспортни протоколи в TCP/IP модела. Те работят на транспортния слой и се използват за различни цели в зависимост от изискванията за надеждност и скорост на комуникацията.

- **TCP (Transmission Control Protocol):**
  - TCP е свързан ориентиран протокол, който осигурява надеждно предаване на данни между два крайни устройства. Той гарантира, че данните ще бъдат доставени в правилния ред и без грешки чрез механизми като потвърждения (ACKs) и повторно изпращане на загубени пакети.
  - TCP е подходящ за приложения, които изискват надеждна комуникация, като уеб браузъри, имейл клиенти и файлови трансфери (HTTP, SMTP, FTP).

- **UDP (User Datagram Protocol):**
  - UDP е безсвързан протокол, който не гарантира доставката, реда или целостта на данните. Той е лек и бърз, тъй като не включва механизми за корекция на грешки и потвърждения.
  - UDP е подходящ за приложения, които изискват бърза и ефективна комуникация, дори с риск от загуба на данни, като стрийминг на видео и аудио, онлайн игри и VoIP (RTP, DNS, DHCP).

- **Номера на портовете в TCP/UDP:**
  - Портовете в TCP и UDP се използват за разграничаване на различни услуги или приложения, които работят на едно и също устройство. Портовете са 16-битови числа и могат да приемат стойности от 0 до 65535.
  - **Добре известни портове (Well-known ports):** 0-1023 – Резервирани за системни или добре известни услуги (напр. HTTP - 80, HTTPS - 443, FTP - 21, SSH - 22).
  - **Регистрирани портове (Registered ports):** 1024-49151 – Могат да се използват от потребителски приложения и услуги (напр. MySQL - 3306, PostgreSQL - 5432, CS2 - 27015).
  - **Динамични или частни портове (Dynamic or private ports):** 49152-65535 – Обикновено се използват за временни връзки и клиентски приложения.

- Сравнение между TCP и UDP:
  - **TCP**: Надеждност, контрол на потока, гарантирано предаване на данни, по-голяма латентност.
  - **UDP**: По-малка латентност, без гаранция за доставяне на данни, подходящ за реално време приложения.

## 5. Полезни Unix команди при работа с мрежови устройства
- `ping` - Командата `ping` служи за тестване на връзката до даден хост в мрежата. Тя изпраща ICMP (Internet Control Message Protocol) echo request съобщения до целевия хост и изчаква отговор. Това помага да се установи дали хостът е достижим и какво е времезакъснението (latency) на връзката.

    Пример:
    ```
    $ ping 8.8.8.8
    PING 8.8.8.8 (8.8.8.8) 56(84) bytes of data.
    64 bytes from 8.8.8.8: icmp_seq=1 ttl=59 time=3.90 ms
    64 bytes from 8.8.8.8: icmp_seq=2 ttl=59 time=3.95 ms
    64 bytes from 8.8.8.8: icmp_seq=3 ttl=59 time=4.25 ms
    64 bytes from 8.8.8.8: icmp_seq=4 ttl=59 time=2.16 ms
    ^C
    --- 8.8.8.8 ping statistics ---
    4 packets transmitted, 4 received, 0% packet loss, time 3004ms
    rtt min/avg/max/mdev = 2.160/3.565/4.251/0.822 ms
    ```

- `traceroute` - Командата `traceroute` служи за проследяване на маршрута, по който пакетите достигат до даден хост в мрежата. Тя показва всяка междинна точка (hop) през която минават пакетите, което помага да се идентифицират проблеми с мрежовите връзки.

    Пример:
    ```
    $ traceroute 8.8.8.8
    traceroute to 8.8.8.8 (8.8.8.8), 30 hops max, 60 byte packets
    1  _gateway (192.168.50.1)  0.872 ms  0.794 ms  0.765 ms
    2  82-137-110-2.ip.btc-net.bg (82.137.110.2)  2.122 ms  2.094 ms  2.037 ms
    3  * * *
    4  * * *
    5  212-39-66-222.ip.btc-net.bg (212.39.66.222)  1.922 ms  2.142 ms  1.895 ms
    6  * * *
    7  dns.google (8.8.8.8)  1.646 ms  1.718 ms  1.696 ms
    ```

    - Бележка: Не всички рутери по трасето отговарят на ICMP пакети, за това някои рутери са отбелязани с `* * *`.

- `nslookup` - Командата `nslookup` служи за запитване на DNS (Domain Name System) сървърите за домейн имена или IP адреси. Тя може да се използва за проверка на DNS записи и за диагностициране на проблеми с DNS резолюцията.

    Пример:
    ```
    $ nslookup dns.google.com
    Server:		192.168.50.1
    Address:	192.168.50.1#53

    Non-authoritative answer:
    Name:	dns.google.com
    Address: 8.8.8.8
    Name:	dns.google.com
    Address: 8.8.4.4
    Name:	dns.google.com
    Address: 2001:4860:4860::8888
    Name:	dns.google.com
    Address: 2001:4860:4860::8844
    ```

## 6. Модел сървър-клиент. Socket комуникация в C.
![Socket комуникация](https://media.geeksforgeeks.org/wp-content/uploads/20220330131350/StatediagramforserverandclientmodelofSocketdrawio2-448x660.png)

1. На сървъра се създава socket канал посредством системната функция `socket()` (виж `man 2 socket`). Съответно, при създаването му се задават:
    - `domain` - Семейството от протоколи, които ще се използват за мрежовата комуникация. Например:
        - `AF_INET` - Използва IPv4 за комуникация.
        - `AF_INET6` - Използва IPv6 за комуникация.
        - `AF_BLUETOOTH` - Използва Bluetooth за комуникация.

    - `type` - Типът на сокета, който определя начина на предаване на данните. Основните типове са:
        - `SOCK_STREAM` - Обезпечава поточна комуникация (TCP).
        - `SOCK_DGRAM` - Обезпечава дейтаграмна комуникация (UDP).
        - `SOCK_SEQPACKET` - Обезпечава последователна пакетна комуникация.

    - `protocol` - Специфичният протокол, който ще се използва. Най-често се задава стойност 0, която избира протокола по подразбиране за дадения тип сокет.

2. На сървъра се извършва свързване на сокета с конкретен адрес и порт чрез функцията `bind()`. Това обвързва сокета със специфичен IP адрес и порт номер, което позволява на сървъра да слуша за входящи връзки.

3. Сървърът започва да слуша за входящи връзки посредством функцията `listen()`. Тази функция превключва сокета в режим на слушане и определя максималния брой връзки, които могат да бъдат опашкани за обработка.

4. Когато сървърът получи заявка за връзка от клиент, той приема връзката с помощта на функцията `accept()`. Тази функция блокира до получаване на заявка за връзка, след което създава нов сокет за комуникация с клиента.

5. След установяване на връзката, сървърът и клиентът могат да започнат да обменят данни чрез функциите `send()` и `recv()` (или съответно `write()` и `read()`). Данните се предават по установената връзка и могат да бъдат обработвани в реално време.

6. След приключване на комуникацията, връзката може да бъде затворена чрез функцията `close()`, която освобождава използваните ресурси.

### Примерен код за сървър в C:

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>

#define PORT 8080

int main() {
    int server_fd, new_socket;
    struct sockaddr_in address;
    int addrlen = sizeof(address);
    char buffer[1024] = {0};
    const char *hello = "Hello from server";

    // Създаване на сокет
    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {
        perror("socket failed");
        exit(EXIT_FAILURE);
    }

    // Задаване на адрес и порт
    address.sin_family = AF_INET;
    address.sin_addr.s_addr = INADDR_ANY;
    address.sin_port = htons(PORT);

    // Свързване на сокета с адреса и порта
    if (bind(server_fd, (struct sockaddr *)&address, sizeof(address)) < 0) {
        perror("bind failed");
        close(server_fd);
        exit(EXIT_FAILURE);
    }

    // Слушане за входящи връзки
    if (listen(server_fd, 3) < 0) {
        perror("listen");
        close(server_fd);
        exit(EXIT_FAILURE);
    }

    // Приемане на входяща връзка
    if ((new_socket = accept(server_fd, (struct sockaddr *)&address, (socklen_t*)&addrlen)) < 0) {
        perror("accept");
        close(server_fd);
        exit(EXIT_FAILURE);
    }

    // Четене на данни от клиента
    int valread = read(new_socket, buffer, 1024);
    printf("%s\n", buffer);

    // Изпращане на данни към клиента
    send(new_socket, hello, strlen(hello), 0);
    printf("Hello message sent\n");

    // Затваряне на сокета
    close(new_socket);
    close(server_fd);

    return 0;
}
```

### Примерен код за клиент в C:

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>

#define PORT 8080

int main() {
    int sock = 0;
    struct sockaddr_in serv_addr;
    const char *hello = "Hello from client";
    char buffer[1024] = {0};

    // Създаване на сокет
    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
        printf("\n Socket creation error \n");
        return -1;
    }

    // Задаване на адрес и порт на сървъра
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_port = htons(PORT);

    // Преобразуване на IP адрес от текстов в бинарен формат
    if (inet_pton(AF_INET, "127.0.0.1", &serv_addr.sin_addr) <= 0) {
        printf("\nInvalid address/ Address not supported \n");
        return -1;
    }

    // Свързване към сървъра
    if (connect(sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {
        printf("\nConnection Failed \n");
        return -1;
    }

    // Изпращане на данни към сървъра
    send(sock, hello, strlen(hello), 0);
    printf("Hello message sent\n");

    // Четене на данни от сървъра
    int valread = read(sock, buffer, 1024);
    printf("%s\n", buffer);

    // Затваряне на сокета
    close(sock);

    return 0;
}
```

Тези примери демонстрират основните стъпки за създаване на сървър и клиент, които комуникират помежду си чрез сокети.